extern "C" %{
/*
 * Copyright (c) 2010-2020 The University of Tennessee and The University
 *                         of Tennessee Research Foundation. All rights
 *                         reserved.
 *
 * @precisions normal z -> s d c
 * $COPYRIGHT
 *
 */
 /* Daniel Mishler attempt to make no migrations occur in a ptg gemm */
#include "dplasmajdf.h"
#include "dplasmaaux.h"
#include "parsec/data_dist/matrix/matrix.h"
#include "parsec/data_dist/matrix/two_dim_rectangle_cyclic.h"
#include <math.h>

#if defined(DPLASMA_HAVE_CUDA)
#include <cublas.h>
#endif  /* defined(DPLASMA_HAVE_CUDA) */

/* Define the different shapes this JDF is using */
#define A_SHAPE 0
#define B_SHAPE 1
#define C_SHAPE 2

/* Assume the functions on type & type_remote will return parsec_arena_datatype_t */
#define JDF2C_TYPE_ADT_NOT_INDEX

/* Include the functions to obtain the parsec_arena_datatype_t */
#include "dplasmajdf_lapack_dtt.h"
//#define FULL_CONVERSION
#ifdef FULL_CONVERSION
#define ADTT_READ(dM, loc, shape, layout) ADTT_DC(dM, loc, shape, layout)
#else
#define ADTT_READ(dM, loc, shape, layout) ADTT_DC(dM, loc, shape, LAPACK)
#endif

/* Note: with this approach to support LAPACK format and minimize
 * the number of tile conversions performed, it is critical to
 * determined the correct location on the matrix where the tile was
 * originated from.
 * Note that the LOC parameters do not correspond to the binding of the
 * task to the matrix (although sometimes they match). These parameters
 * correspond to the location were the datacopy was originate on the matrix (maybe
 * it was read on another task).
 * If there is no possibility to determine it (datacopy passed along multiple
 * tasks and that information is lost) the approach is to force a reshapping.
 *
 */

/* As of 2023-03-06, only NN is implemented */
#include "zgemm_NN_mtest.h"

%}

/*
 * Globals
 */

/* Keep this first, as in all jdf in this directory, to
 * enable switching between GEMM implementations.
 */
gemm_type [ type = int hidden=on default="DPLASMA_ZGEMM_NN_MTEST" ]

transA [type = int]
transB [type = int]

alpha  [type = dplasma_complex64_t]
beta   [type = dplasma_complex64_t]

ddescA     [type = "dplasma_data_collection_t*"]
descA      [type = "parsec_tiled_matrix_t*" hidden = on default = "((dplasma_data_collection_t*)ddescA)->dc_original" aligned=ddescA]

ddescB     [type = "dplasma_data_collection_t*"]
descB      [type = "parsec_tiled_matrix_t*" hidden = on default = "((dplasma_data_collection_t*)ddescB)->dc_original" aligned=ddescB]

ddescC     [type = "dplasma_data_collection_t*"]
descC      [type = "parsec_tiled_matrix_t*" hidden = on default = "((dplasma_data_collection_t*)ddescC)->dc_original" aligned=ddescC]

Cdist  [type = "parsec_data_collection_t *"]

P      [type = "int" hidden=on default="((parsec_matrix_block_cyclic_t*)descC)->grid.rows"]
Q      [type = "int" hidden=on default="((parsec_matrix_block_cyclic_t*)descC)->grid.cols"]

/* Look ahead on both dimensions */
lookP  [type = "int" hidden=on default="dplasma_aux_getGEMMLookahead(descC)"]
lookQ  [type = "int" hidden=on default="dplasma_aux_getGEMMLookahead(descC)"]

/**************************************************
 *                       READ_A                   *
 **************************************************/
READ_A(m, k)  [profile = off]

m = 0 .. descA->mt-1
k = 0 .. descA->nt-1

loc_A = %{ return LOC(descA, m, k); %}

: descA(m, k)

READ A <- ddescA(m, k)        [ type        = %{ return ADTT_READ(ddescA, loc_A, A_SHAPE, TILED); %}
                                type_data   = %{ return ADTT_READ(ddescA, loc_A, A_SHAPE, LAPACK); %} ]
       -> A RING_A(m, k, k%Q) /* dep OUT: rely on datacopy dtt for sending */
/* has to be here because I don't know how ringa works */
// READ DEPA <- ddescA(m, k)
          // -> DEPA GEMM(m, 0 .. descC->nt-1, k)
// READ ALLREADA <- ddescA(m,k)
              // -> (m == descA->mt-1 && k==descA->nt-1) ? ALLREADA GEMM(0 .. descC->mt-1, 0 .. descC->nt-1, 0 .. descA->nt-1)

BODY
{
    printlog("rank %u <- A(%d,%d)\n", ((parsec_data_collection_t*)descA)->myrank, m, k);
}
END

RING_A(m, k, q)  [profile = off]

m = 0 .. descA->mt-1
k = 0 .. descA->nt-1
q = 0 .. Q-1
prevq = (q-1+Q)%Q
nextq = (q+1)%Q

loc_A = %{ return LOC(descA, m, k); %}

: Cdist(m, q)

READ A <- (k%Q == q) ? A READ_A(m, k) : A RING_A(m, k, prevq) [ type_remote = %{ return ADTT_DC(ddescA, loc_A, A_SHAPE, TILED); %} ]
       -> A GEMM(m, q .. descC->nt-1 .. Q, k)                 /* dep OUT: rely on datacopy dtt for sending */
       -> (nextq != (k%Q)) ? A RING_A(m, k, nextq)            /* dep OUT: rely on datacopy dtt for sending */
// CTL  ALLRINGA -> (m == descA->mt-1 && k == descA->nt-1 && q == Q-1) ? ALLRINGA GEMM(0 .. descC->mt-1, 0 .. descC->nt-1, 0 .. descA->nt-1)
CTL  ALLRINGA -> (m == descA->mt-1 && k == descA->nt-1 && q == Q-1) ? ALLRINGA ACCUMULATOR_A(0)

CTL ctla <- (k >= lookQ) ? ctla GEMM(m, q .. descC->nt-1 .. Q, k-lookQ)

BODY
{
    printlog("rank %u <- A(%d,%d)\n", ((parsec_data_collection_t*)descA)->myrank, m, k);
}
END

/**************************************************
 *                  ACCUMULATOR_A                 *
 **************************************************/
ACCUMULATOR_A(a) [profile = off]

// I don't know what these parameters define.
a = 0 .. 0

: descA(0,0)

CTL  ALLRINGA <- ALLRINGA RING_A(descA->mt-1, descA->nt-1, Q-1)
CTL  ALL_READ_A -> ALL_READ_A ACCUMULATOR_6x6(0,0)

BODY
{
   // printf("accumulator A running!\n");
   printlog("A accumulated\n");
}
END


/**************************************************
 *                       READ_B                   *
 **************************************************/
READ_B(k, n) [profile = off]

n = 0 .. descB->nt-1
k = 0 .. descB->mt-1

loc_B = %{ return LOC(descB, k, n); %}

: descB(k, n)

READ B <- ddescB(k, n)        [ type        = %{ return ADTT_READ(ddescB, loc_B, B_SHAPE, TILED); %}
                                type_data   = %{ return ADTT_READ(ddescB, loc_B, B_SHAPE, LAPACK); %} ]
       -> B RING_B(k, n, k%P) /* dep OUT: rely on datacopy dtt for sending */
// READ ALLREADB <- ddescB(k,n)
              // -> (k == descB->nt-1 && n == descB->mt-1) ? ALLREADB GEMM(0 .. descC->mt-1, 0 .. descC->nt-1, 0 .. descA->nt-1)
BODY
{
     printlog("rank %u <- B(%d,%d)\n", ((parsec_data_collection_t*)descB)->myrank, k, n);
}
END

RING_B(k, n, p)  [profile = off]

k = 0 .. descB->mt-1
n = 0 .. descB->nt-1
p = 0 .. P-1
prevp = (p-1+P)%P
nextp = (p+1)%P

loc_B = %{ return LOC(descB, k, n); %}

: Cdist(p, n)

READ B <- (k%P == p) ? B READ_B(k, n) : B RING_B(k, n, prevp) [ type_remote = %{ return ADTT_DC(ddescB, loc_B, B_SHAPE, TILED); %} ]
       -> B GEMM(p .. descC->mt-1 .. P, n, k)                 /* dep OUT: rely on datacopy dtt for sending */
       -> (nextp != (k%P)) ? B RING_B(k, n, nextp)            /* dep OUT: rely on datacopy dtt for sending */
CTL ALLRINGB -> (k == descB->mt-1 && n == descB->nt-1 && p == P-1) ? ALLRINGB ACCUMULATOR_B(0)

CTL ctlb <- (k >= lookP) ? ctlb GEMM(p .. descC->mt-1 .. P, n, k-lookP)

BODY
{
    printlog("rank %u <- B(%d,%d)\n", ((parsec_data_collection_t*)descB)->myrank, k, n);
}
END

/**************************************************
 *                  ACCUMULATOR_B                 *
 **************************************************/
ACCUMULATOR_B(b) [profile = off]

b = 0 .. 0

: descB(0,0)

CTL  ALLRINGB <- ALLRINGB RING_B(descA->mt-1, descA->nt-1, Q-1)
CTL  ALL_READ_B -> ALL_READ_B ACCUMULATOR_6x6(0,0)

BODY
{
   // printf("accumulator B running!\n");
   printlog("B accumulated\n");
}
END

/**************************************************
 *              ACCUMULATOR_6x6                   *
 **************************************************/
ACCUMULATOR_6x6(mst, nst) [profile = off]
mst = 0 .. ((descC->mt-1) / 6)
nst = 0 .. ((descC->nt-1) / 6)

: descC(mst*6, nst*6)
// : descB(0,0)

CTL ALL_READ_A <- (mst == 0 && nst == 0) ? ALL_READ_A ACCUMULATOR_A(0)
CTL ALL_READ_B <- (mst == 0 && nst == 0) ? ALL_READ_B ACCUMULATOR_B(0)
CTL PASS_M  <- (mst != 0) ? PASS_M ACCUMULATOR_6x6(mst-1, nst)
            -> (mst != (descC->mt-1)/6) ? PASS_M ACCUMULATOR_6x6(mst+1, nst)
CTL PASS_N  <- (mst == 0 && nst != 0) ? PASS_N ACCUMULATOR_6x6((descC->mt-1)/6, nst-1)
            -> (mst == (descC->mt-1)/6) ? PASS_N ACCUMULATOR_6x6(0, nst+1)
CTL BLOCK_START -> BLOCK_START GEMM(mst*6 .. mst*6+5, nst*6 .. nst*6+5, 0)
CTL ACCUM_START <- (mst != 0 || nst != 0) ? ACCUM_START GEMM((mst-1)*6, nst*6, ((descA->nt-1)*3)/5)
                <- (mst == 0 && nst != 0) ? ACCUM_START GEMM(((descC->mt-1)/6)*6, (nst-1)*6, ((descA->nt-1)*3)/5)


BODY
{
    printlog("accumulator_6x6 for mst=%d,nst=%d\n", mst, nst);
    // printf("accumulator_6x6 for mst=%d,nst=%d\n", mst, nst);
}
END


/**************************************************
 *                       GEMM                     *
 **************************************************/
GEMM(m, n, k) [ flops = inline_c%{ return FLOPS_ZGEMM(CLEAN_MB(descC, m), CLEAN_NB(descC, n), CLEAN_NB(descA, k)); %} ]

// Execution space
m = 0 .. descC->mt-1
n = 0 .. descC->nt-1
k = 0 .. descA->nt-1

loc_A = %{ return LOC(descA, m, k); %}
loc_B = %{ return LOC(descB, k, n); %}
loc_C = %{ return LOC(descC, m, n); %}

// Parallel partitioning
: descC(m, n)

// Parameters
READ A <- A RING_A(m, k, n%Q)                         [ type_remote = %{ return ADTT_DC(ddescA, loc_A, A_SHAPE, TILED); %} ]
READ B <- B RING_B(k, n, m%P)                         [ type_remote = %{ return ADTT_DC(ddescB, loc_B, B_SHAPE, TILED); %} ]
RW   C <- (k == 0)             ? ddescC(m, n)         [ type        = %{ return ADTT_READ(ddescC, loc_C, C_SHAPE, TILED); %}
                                                        type_data   = %{ return ADTT_READ(ddescC, loc_C, C_SHAPE, LAPACK); %} ]
       <- (k != 0)             ? C GEMM( m, n, k-1 )  [ type_remote = %{ return ADTT_DC(ddescC, loc_C, C_SHAPE, TILED); %} ]
       -> (k == (descA->nt-1)) ? ddescC(m, n)         [ type        = %{ return ADTT_CP(_f_C, ddescC, loc_C, C_SHAPE); %}
                                                        type_data   = %{ return ADTT_DC(ddescC, loc_C, C_SHAPE, LAPACK); %} ]
       -> (k != (descA->nt-1)) ? C GEMM( m, n, k+1 )  /* dep OUT: rely on datacopy dtt for sending */


CTL BLOCK_START <- (k == 0) ? BLOCK_START ACCUMULATOR_6x6(m/6, n/6)

CTL ACCUM_START -> (k == ((descA->nt-1)*3)/5 && m % 6 == 1 && n % 6 == 1 && m/6 < (descC->mt-1)/6) ? ACCUM_START ACCUMULATOR_6x6(m/6+1,n/6)
                -> (k == ((descA->nt-1)*3)/5 && m % 6 == 1 && n % 6 == 1 && m/6 == (descC->mt-1)/6) ? ACCUM_START ACCUMULATOR_6x6(0,n/6+1)


// CTL  DEPCN <- (n >= 6 && k == 0)  ? DEPCN GEMM(m, n-6, descA->nt-1)
           // -> (k == descA->nt-1) ? DEPCN GEMM(m, n+6, 0 .. descA->nt-1)
// CTL  DEPCM <- (m >= 6 && k == 0)  ? DEPCM GEMM(m-6, n, descA->nt-1)
           // -> (k == descA->nt-1) ? DEPCM GEMM(m+6, n, 0 .. descA->nt-1)

// RW   DEPCM <- (m < 6 )  ? descC(m, n)
           // <- (m >= 6)  ? DEPCM GEMM(m-6, n, k)
           // // -> DEPCM GEMM(m+6, n, k)


CTL ctla -> (k < (descA->nt-lookQ)) ? ctla RING_A(m, k+lookQ, n%Q)
CTL ctlb -> (k < (descA->nt-lookP)) ? ctlb RING_B(k+lookP, n, m%P)

BODY [type=CUDA
      dyld=cublasZgemm dyldtype=cublas_zgemm_t
      weight=(descA->nt-k)
      A.size=%{ return descA->mb*descA->nb*parsec_datadist_getsizeoftype(descA->mtype);%}
      B.size=%{ return descB->mb*descB->nb*parsec_datadist_getsizeoftype(descB->mtype);%}
      C.size=%{ return descC->mb*descC->nb*parsec_datadist_getsizeoftype(descC->mtype);%}
      A.dc=ddescA B.dc=ddescB C.dc=ddescC
      stage_in=stage_in_lapack
      stage_out=stage_out_lapack]
{
#if defined(PRECISION_z) || defined(PRECISION_c)
    cuDoubleComplex lalpha = make_cuDoubleComplex(creal(alpha), cimag(alpha));
    cuDoubleComplex lbeta  = (k == 0) ? make_cuDoubleComplex(creal(beta), cimag(beta))
                                      : make_cuDoubleComplex(1.0, 0.0);
#else
    double lalpha = alpha;
    double lbeta  = (k == 0) ? beta : 1.0;
#endif
    int tempmm = m == descC->mt-1 ? descC->m - m * descC->mb : descC->mb;
    int tempnn = n == descC->nt-1 ? descC->n - n * descC->nb : descC->nb;
    int tempkk = k == descA->nt-1 ? descA->n - k * descA->nb : descA->nb;
    int ldam = descA->mb;
    int ldbk = descB->mb;
    int ldcm = descC->mb;

    cublasStatus_t status;
    cublasSetKernelStream( parsec_body.stream );
    parsec_body.dyld_fn( dplasma_lapack_const(transA), dplasma_lapack_const(transB),
             tempmm, tempnn, tempkk,
             lalpha, (cuDoubleComplex*)A, ldam,
                     (cuDoubleComplex*)B, ldbk,
             lbeta,  (cuDoubleComplex*)C, ldcm );
    status = cublasGetError();
    PARSEC_CUDA_CHECK_ERROR( "cublasZgemm ", status,
                            {return -1;} );
}
END

BODY
{

    dplasma_complex64_t lbeta = (k == 0) ? beta : (dplasma_complex64_t)1.0;
    int tempmm = m == descC->mt-1 ? descC->m - m * descC->mb : descC->mb;
    int tempnn = n == descC->nt-1 ? descC->n - n * descC->nb : descC->nb;
    int tempkk = k == descA->nt-1 ? descA->n - k * descA->nb : descA->nb;
    int ldam = LDA(ddescA, A);
    int ldbk = LDA(ddescB, B);
    int ldcm = LDA(ddescC, C);

    // printf("GEMM m=%d, n=%d, k=%d\n", m, n, k);
    CORE_zgemm(transA, transB,
               tempmm, tempnn, tempkk,
               alpha, A /*A(m, k)*/, ldam,
                      B /*B(k, n)*/, ldbk,
               lbeta, C /*C(m, n)*/, ldcm);

    printlog("gemm( %d, %d, %d )\n"
             "    ( %s, %s, %d, %d, %d, %f, A(%d,%d), %d, B(%d,%d), %d, %f, C(%d,%d), %d)\n",
             m, n, k,
             &dplasma_lapack_const( transA ), &dplasma_lapack_const( transB ),
             tempmm, tempnn, tempkk,
             creal(alpha), m, k, ldam,
                           k, n, ldbk,
             creal(lbeta), m, n, ldcm );
}
END
